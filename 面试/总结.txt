JVM:
    堆栈：
    堆：存放对象和数组 （GC）
    栈：存放局部变量，方法调用 
    方法区
    程序计数器

    GC：
    标记-清除 --》内存碎片
    拷贝 --》 浪费资源（留有备份区间）
    标记-整理 --》没有内存碎片
    分代收集（新生代，老年代）-新生代采用拷贝算法（Eden，Survivor），老年代采用标记整理算法

    Minor GC: 新生代（拷贝算法）
    Major GC：老年代（标记-整理算法）
    Full GC：对整个堆

    类加载机制：
    解析，加载，验证，准备，初始化

Collection:
    HashMap:数组，链表(1.8 红黑树,段锁改为node锁)
    ConcurrentHashMap: CAS+syncronized

RPC:    
    gRPC：2015年有Google提出的高性能远端程序调用框架技术，基于HTTP2.0，序列化方式采用protobuffer二进制传输，语言无关性。
    thrift基于http1.0。
    http1.0：每次请求建立一个新的TCP链接，请求完关闭
    http1.1：支持长连接，请求会被管道执行，容易阻塞
    http2.0:双向流，多路复用（每个请求有唯一ID区分）
    
网络协议：
    http与https的区别：
    端口不同，http是80端口，https是443端口
    资源消耗：https需要加密，需要更多的CPU和内存资源
    开销：https需要证书

    对称加密/非对称加密
    对称加密：加密解密使用同一个密钥
    非对称加密：公钥私钥

    TCP:可靠连接协议，三次握手链接，四次挥手断链
    UDP：无连接协议，允许丢包（视频语音电话）

Redis:
    Remote Dictionary server(NoSQL)非关系型键值对数据库
    String,Set,List,Hash，SortedSet
    Redis数据存在内存中，读写快
    数据持久化： RDB快照，AOF持久化
    为什么快： 基于内存，数据结构简单，NIO，单线程
    Redis事务：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。（不支持回滚）
    Mutile开启
    Exec执行
    Watch监控
    Redis的过期策略：
    定时过期
    惰性过期
    定期过期

    缓存穿透：Redis没有数据，导致所有请求到数据库（设置Key-null的值在Redis，设置短的有效时间）
    缓存雪崩：缓存大面积失效（加锁排队，随机失效时间，标记缓存是否失效）
    缓存击穿：大量单点数据请求数据库（热点数据不失效，加互斥锁）


    Redis保证缓存与数据库数据一致性：
    延迟双删 - 不推荐
    分布式锁（读写锁）-强一致性
    Canal订阅mysql binlog同步机制+消息队列+retry - 弱一致性

    实现分布式锁：
    1. 原子性操作，操作简单
    2. 基于内存的操作，高性能
    3. 支持自动过期，避免死锁
    4. 支持分布式环境

    可以设置过期时间，支持自动续期：
    创建守护线程（Redission看门狗）

MySQL:
    数据库三范式：
    列不可再分
    非主键字段完全依赖于主键
    非主键字段不能依赖于其他非主键

    数据类型：整型，浮点型，字符型，枚举型，日期型

    存储引擎：MyISAM/InnoDB
    InnoDB支持事务/MyISAM不支持
    InnoDB使用行级锁/MyISAM使用表级锁
    InnoDB支持外键约束/MyISAM不支持外键约束
    InnoDB在高并发和大型事务有优势/MyISAM在读多场景有优势

    索引：
    主键索引，唯一索引，普通索引，复合索引，全文索引
    B+树索引（适应于范围查询，支持排序），hash索引（适应于等值查询）
    B树索引：键值都存在叶子节点
    B+树：非叶子节点只存键

    事务：
    ACID
    原子性
    一致性
    隔离性
    持久性
    隔离级别：（并发性能/数据一致性 取舍）
    读取未提交：脏读，幻读，不可重复读（读取到别人未提交的改动）
    读取已提交：不可重复读，幻读（一次事务多次查询结果不一致）
    可重复读：幻读（别的事务插入）
    可串行读：完全一致

    隔离性问题：
    脏读：读到别的事务未提交的改动
    幻读：事务中被别的事务插入
    不可重复读：一次事务多次读取数据不一致

    SQL优化：
    创建合理的索引
    优化SQL语句
    分区分表
    缓存机制

    数据库日志：
    Redo Log:数据库崩溃恢复，事务提交之前必须写入
    Undo Log：事务回滚（保存修改之前的数据）
    Bin Log：主从同步，数据恢复（语句模式，行模式，混合模式）

    数据库并发实现：MVCC（多版本控制）
    1. 自增长的事务ID
    2. 事务ID，row ID，回滚指针

    基于undolog和read view实现，undo log保存历史快照，ReadView提供可见性规则

    总结：
    innodb引擎：undolog保证原子性，redolog保证持久性，读写锁，mvcc保证隔离性

Kafka高性能：
    1.零拷贝
    2.顺序写
    3.批量操作

    Kafka如何保证不重复消费，又不丢失数据：
    1.生产者确认机制（0-不等待服务器确认，1-等待master确认，-1-等待所有服务器确认）
    2.消息持久化，副本机制，ISR
    3.消费者确认机制（auto commit/manual commit）
    4.幂等生产者

    消息乱序：按照业务，相同类型的消息发布同一个partition

SpringCloud:
    微服务特征：
    单一职责
    面向服务
    自治
    隔离性强

    组件：
    Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；
    Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；
    Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；
    Feign：基于Ribbon和Hystrix的声明式服务调用组件；
    Zuul/Gateway：API网关组件，对请求提供路由及过滤功能。


    服务熔断： Hystrix

    服务注册发现：
    Eureka：高可用性
    Zookeeper：一致性

    RPC： 服务端与客户端通过序列化反序列化对面，网络传输字节码，服务端提供服务接口，客户端实现
    Nginx：高性能http服务和反向代理
    多进程机制
    异步非阻塞机制

    正向代理：代理服务器在客户端
    反向代理：代理服务器在服务端

    处理服务雪崩： 服务降级/服务熔断

    Ribbon策略：轮询，随机，权重，区域敏感

JUC:
    volatile关键字：保证可见性，不保证原子性，可以防止指令重排

    创建多线程方法：
    1. 继承Thread
    2. 实现Runnable
    3. 实现Callable
    4. 线程池

    线程生命周期：
    new
    Runnable - 等待CPU调度
    running
    blocked
    waiting
    timed_waiting
    terminated

    保证线程顺序：
    wait()
    notify()

    join()

    并行和并发：
    并发是单一CPU利用JVM不在同一时间运行
    并行调用多CPU真正实现同时处理

    线程池的核心参数：
    最大线程数
    核心线程数
    任务队列
    线程存活时间
    存活时间单位
    线程工厂
    拒绝策略

    创建线程池的方法：
    ThreadPoolExecutor
    ExecutorService

    拒绝策略：
    AbortPolicy: throw exception
    DiscardPolicy: ignore new task
    DiscardOldestPolicy: ignore the oldest task
    CallerRunsPolicy: run by self not threadpool

    ThreadLocal：每个线程独立的本地变量副本

ES:
    倒排序：
    通过分词策略生成词与文章的映射表，查询时间复杂度：O（1）

    搜索过程：
    query then fetch

    并发读写一致：
    1. 同步双写：写入DB时，同时写到ES
    2. 异步双写：借助MQ
    3. 定时同步
    4. Binlog实时同步（Canal server），接收日志，写入MQ

k8s:
    Master Slave结构

    通信：
    pod 内：localhost
    pod之间：虚拟网桥
    对外：nodeport，LB， Ingress

    master节点：
    etcd，一种的分布式存储机制，底层采用 Raft 协议，k8s 集群的状态数据包括配置、节点等都存储于 etcd 中，它保存了整个集群的状态。
    API server，对外提供操作和获取 k8s 集群资源的的 API，是唯一操作 etcd 的组件，其他的组件包括管理员操作都是通过 API server 进行交互的，可以将它理解成 etcd 的 “代理人”。
    Scheduler，在 k8s 集群中做调动决策，负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上。
    Controller Manager，相当于集群状态的协调者，观察着集群的实际状态，与 etcd 中的预期状态进行对比，如果不一致则对资源进行协调操作让实际状态和预期状态达到最终的一致，维护集群的状态，比如故障检测、自动扩展、滚动更新等。

    woker节点：
    Controller Runtime，下载镜像和运行容器的组件，负责镜像管理以及 Pod 和容器的真正运行（CRI）。
    Pod，k8s 中特有的一个概念，可以理解为对容器的包装，是 k8s 的基本调度单位，实际的容器时运行在 Pod 中的，一个节点可以启动一个或多个 Pod。
    kubelet，负责管理 worker 节点上的组件，与 master 节点上的 API server 节点进行交互，接受指令执行操作。
    kube-proxy，负责对 Pod 进行寻址和负载均衡

    核心概念：
    Cluster：集群有多个节点组成且可以按需添加节点（物理机/虚拟机），每一个节点都包含一定数量的 CPU 和内存 RAM。
    Container：k8s 本身是一个容器调度平台，从宿主机操作系统来看，容器就是一个一个的进程。从容器内部来看容器就是一个操作系统，它有着自己的网络、CPU、文件系统等资源。
    POD：k8s 也不是直接调度容器的，而是将其封装成了一个个 POD，POD 才是 k8s 的基本调度单位。每个 POD 中可以运行一个或多个容器，共享 POD 的文件系统、IP 和网络等资源，每一个 POD 只有一个 IP。
    副本集 ReplicaSet：一个应用发布时会发布多个 POD 实例，副本集可对应一个应用的一组 POD，它可以通过模板来规范某个应用的容器镜像、端口，副本数量等。运行时副本集会监控和维护 POD 的数量，数量过多则会下线 POD，过少则启动 POD。
    服务 service：POD 在 k8s 中是不固定的，可能会挂起或者重启，且挂起重启都是不可预期的，那么这就会导致服务的 IP 也随着不停的变化，给用户的寻址造成一定的困难。而 service 就是用来解决这个问题的，它屏蔽了应用的 IP 寻址和负载均衡，消费方可直接通过服务名来访问目标服务，寻址和负载均衡均由 service 底层进行。
    发布 Deployment：副本集就是一种基本的发布机制，可以实现基本的或者高级的应用发布，但操作较为繁琐。未来简化这些操作，k8s 引入了 Deployment 来管理 ReplicaSet，实现一些高级发布机制。
    ConfigMap/Secret：
    微服务在上线时需要设置一些可变配置，环境不同则配置值不同，有些配置如数据库的连接字符串在启动时就应该配好，有些配置则可以在运行中动态调整。为了实现针对不同环境灵活实现动态配置，微服务就需要 ConfigMap 的支持。
    k8s 平台内置支持微服务的配置（ConfigMap），开发人员将配置填写在 ConfigMap 中，k8s 再 将 ConfigMap 中的配置以环境变量的形式注入 POD，这样 POD 中的应用就可以访问这些配置。
    Secret 是一种特殊的 ConfigMap，提供更加安全的存储和访问配置机制。
    DaemonSet：
    在微服务中，每个节点需要配置一个常驻守护进程。DaemonSet 可支持在每一个 worker 节点上面配置一个守护进程 POD 并且保证每一个节点上有且仅有一个 POD。

    Kubernetes 中的 Deployment 和 StatefulSet 有何区别？
    Deployment 用于部署无状态应用程序，而 StatefulSet 用于部署有状态应用程序。StatefulSet 可以保证应用程序的唯一性和顺序性，同时支持有状态服务的动态扩展和缩减等操作。
